#数独的自动求解

  数独有9×9格，理论上有9的81次方组合。据百度，有6,670,903,752,021,072,936,960（约有6.67×10的21次方）种组合，2005年由Bertram Felgenhauer和Frazer Jarvis计算出该数字，如果将重复（如数字交换、对称等）不计算，那么有5,472,730,538个组合。也就是说靠计算机穷举是无法求解的。
  目前解题思路是模拟人解题的删减法的思考过程：
  1. 在空格上填上所有可能的数值选项（1-9）<初始化>
  2. 根据已确定格子的数值，比如数字为A，把本行，本列和本块内空格里面的A选项去掉 <去重>
  3. 再检视一下第一轮删减后的结果，有没有出现新的确定格子（只有1个解），如果有再针对新出现的值再删减一轮，直到删无可删。<检查结果>

 /*一般前三步人是混在一起做的，为了描述清晰分开来*/
 
  4. 烧脑从这里开始。一般不会有这么简单的数独，通过简单的删减直接解出来。这时候有很多格子还有多个可选项，这时候找一个可选项最少的（为什么找最少的，我直觉从这里猜一个数字解解看最高效，比如只有2个数字，一个数字解不下去，另一个一定是对的），穷举其中的数字选项，也就是猜一个值，再重复2,3的过程。<穷举>
  5. 猜了之后又两种可能：1.解到最后一步把所有格子填满，而且满足数独条件。2.解到一半发现有格子填不下去，是空的
  6. 如果出现有的格子把数字删光了，是空的填不下去了。说明上一步猜的不对，回到上一步用另外的值再解解看，要回复到当时的数字状态。人脑很难记住那么多数字状态，特别是在猜了多个数字之后，但电脑擅长啊。<检查结果，递归>
  7. 猜的过程中如果得到有效结果，可以直接输出并退出，也可以把剩下的值都穷举完，可能会有多个解。
  
  一样6步就是完整的解题思路，传统递归解法即可

 
同样的算法，同一个题目，python3用了4秒多，C语言用了0.04秒。
C语言中，为了节省空间(复习位操作)，用了1个16位的无符号整数表示1-9，第1位表示1，第2位表示2....还用第11位表示是否是确定值。所以内存占用数量是少了很多的，其实可以拿空间换时间，直接存数字结果，不用把位数翻译成数字，但做完发现解题时间在百分之几秒内，还是算了。
 
